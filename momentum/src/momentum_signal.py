import pandas as pd
import numpy as np
from datetime import datetime
from keras.models import Sequential
from keras.layers import LSTM, Dense, Activation
import theano
theano.config.compute_test_value = 'off'
from sklearn.metrics import accuracy_score

import utils

def MOP_momentum(day_return, look_back=12, period="monthly"):
    """
    extract momentum signal from daily return

    input
    -----------------------------
    day_return: daily return

    output
    -----------------------------
    return: dataframe of strategy, it has to columns
            df[contract] is the relative value compared to 1
            df["momentum"] is the daily/weekly/monthly momentum signal generated by algorithm
    """
    contract = day_return.name
    # calculate daily volatility scaling, see the formula in paper
    day_vol = day_return.ewm(ignore_na=False, adjust=True, com=60, min_periods=0).std(bias=False)
    vol = day_vol * np.sqrt(261) # annualise

    ret_index = (1 + day_return).cumprod()
    ret_index[0] = 1
    ret_index = pd.concat([ret_index, vol], axis=1)
    ret_index.columns = [contract, "%s_vol"%(contract)]

    if period == "monthly" or period == "weekly":
        # get monthly return and volatility
        resample_period = utils.period2resample_period(period)
        ret_m_index = ret_index.resample(resample_period).last().ffill()
        ret_m_index.ix[0][contract] = 1
        df = ret_m_index.copy()
    elif period == "daily":
        df = ret_index.copy()
    df["momentum"] = df[contract].pct_change(look_back)
    return df

def average_momentum(day_return, look_back=12, period="monthly"):
    ret_index = (1 + day_return).cumprod()
    ret_index[0] = 1
    if period == "monthly" or period == "weekly":
        resample_period = utils.period2resample_period(period)
        ret_m_index = ret_index.resample(resample_period).last().ffill()
        df = pd.DataFrame(ret_m_index)
        period_mean = day_return.resample(resample_period).mean() # average return by month or week
        df["momentum"] = period_mean.rolling(window=look_back).mean()
    elif period == "daily":
        df = pd.DataFrame(ret_index)
        df["momentum"] = day_return.rolling(window=look_back).mean()
    return df

# convert an array of values into a dataset matrix
def create_dataset(dataset, look_back=12):
    dataX, dataY = [], []
    for i in range(len(dataset) - look_back):
        a = dataset[i:(i+look_back)]
        dataX.append(a)
        dataY.append(dataset[i + look_back])
    return np.array(dataX), np.array(dataY)

def lstm_momentum(day_return, look_back=12, period="monthly", feature_dim=32):
    np.random.seed(1234)

    if period == "monthly" or period == "weekly":
        resample_period = utils.period2resample_period(period)
        day_return = day_return.resample(resample_period).last().ffill()

    split_date = datetime(2010, 1, 1)
    train = day_return[day_return.index < split_date]
    test = day_return[day_return.index >= split_date]
    train = train.values.astype('float32')
    test = test.values.astype('float32')

    assert(train.shape[0] != 0)
    assert(test.shape[0] != 0)

    # reshape into X=t and Y=t+1
    trainX, trainY = create_dataset(train, look_back)
    testX, testY = create_dataset(test, look_back)
    trainY = (trainY > 0).astype(int)
    testY = (testY > 0).astype(int)

    # reshape intput to be [samples, time steps, features]
    trainX = np.reshape(trainX, (trainX.shape[0], 1, trainX.shape[1]))
    testX = np.reshape(testX, (testX.shape[0], 1, testX.shape[1]))

    # create and fit the LSTM network
    model = Sequential()
    model.add(LSTM(feature_dim, input_dim=look_back))
    model.add(Dense(1))
    model.add(Activation('sigmoid'))
    model.compile(loss='binary_crossentropy', optimizer='adam', metrics=["accuracy"])
    # model.compile(loss='mean_squared_error', optimizer='adam')
    model.fit(trainX, trainY, nb_epoch=20, batch_size=4, verbose=2)

    # generate predictions for training
    # trainPredict = model.predict_proba(trainX)
    testPredict = model.predict_classes(testX)
    # print testPredict
    testPredict[testPredict == 0] = -1

    # test dayily return
    day_return = day_return[day_return.index > split_date]
    ret_index = (1 + day_return).cumprod()
    ret_index[0] = 1
    df = pd.DataFrame(ret_index)
    df["momentum"] = np.nan
    df["momentum"][-testPredict.shape[0]-1:-1] = testPredict[:, 0]
    df.dropna(inplace=True)
    print("Prediction:\n------------------------------------")
    score, acc = model.evaluate(testX, testY, batch_size=4)
    print score, acc
    return df
